//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MeshIO.Formats.Gltf.Schema.V2;
internal interface IGltfNamedObject
{
	public string Name { get; set; }
}
internal class GltfRoot
{

	/// <summary>
	/// Backing field for ExtensionsUsed.
	/// </summary>
	private string[] _extensionsUsed;

	/// <summary>
	/// Backing field for ExtensionsRequired.
	/// </summary>
	private string[] _extensionsRequired;

	/// <summary>
	/// Backing field for Accessors.
	/// </summary>
	private GltfAccessor[] _accessors;

	/// <summary>
	/// Backing field for Animations.
	/// </summary>
	private GltfAnimation[] _animations;

	/// <summary>
	/// Backing field for Asset.
	/// </summary>
	private GltfAsset _asset;

	/// <summary>
	/// Backing field for Buffers.
	/// </summary>
	private GltfBuffer[] _buffers;

	/// <summary>
	/// Backing field for BufferViews.
	/// </summary>
	private GltfBufferView[] _bufferViews;

	/// <summary>
	/// Backing field for Cameras.
	/// </summary>
	private GltfCamera[] _cameras;

	/// <summary>
	/// Backing field for Images.
	/// </summary>
	private GltfImage[] _images;

	/// <summary>
	/// Backing field for Materials.
	/// </summary>
	private GltfMaterial[] _materials;

	/// <summary>
	/// Backing field for Meshes.
	/// </summary>
	private GltfMesh[] _meshes;

	/// <summary>
	/// Backing field for Nodes.
	/// </summary>
	private GltfNode[] _nodes;

	/// <summary>
	/// Backing field for Samplers.
	/// </summary>
	private GltfSampler[] _samplers;

	/// <summary>
	/// Backing field for Scene.
	/// </summary>
	private System.Nullable<int> _scene;

	/// <summary>
	/// Backing field for Scenes.
	/// </summary>
	private GltfScene[] _scenes;

	/// <summary>
	/// Backing field for Skins.
	/// </summary>
	private GltfSkin[] _skins;

	/// <summary>
	/// Backing field for Textures.
	/// </summary>
	private GltfTexture[] _textures;

	/// <summary>
	/// Backing field for Extensions.
	/// </summary>
	private System.Collections.Generic.Dictionary<string, object> _extensions;

	/// <summary>
	/// Backing field for Extras.
	/// </summary>
	private GltfExtras _extras;

	/// <summary>
	/// Names of glTF extensions used somewhere in this asset.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("extensionsUsed")]
	public string[] ExtensionsUsed
	{
		get
		{
			return this._extensionsUsed;
		}
		set
		{
			this._extensionsUsed = value;
		}
	}

	/// <summary>
	/// Names of glTF extensions required to properly load this asset.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("extensionsRequired")]
	public string[] ExtensionsRequired
	{
		get
		{
			return this._extensionsRequired;
		}
		set
		{
			if ((value == null))
			{
				this._extensionsRequired = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._extensionsRequired = value;
		}
	}

	/// <summary>
	/// An array of accessors.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("accessors")]
	public GltfAccessor[] Accessors
	{
		get
		{
			return this._accessors;
		}
		set
		{
			if ((value == null))
			{
				this._accessors = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._accessors = value;
		}
	}

	/// <summary>
	/// An array of keyframe animations.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("animations")]
	public GltfAnimation[] Animations
	{
		get
		{
			return this._animations;
		}
		set
		{
			if ((value == null))
			{
				this._animations = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._animations = value;
		}
	}

	/// <summary>
	/// Metadata about the glTF asset.
	/// </summary>
	[Newtonsoft.Json.JsonRequiredAttribute()]
	[Newtonsoft.Json.JsonPropertyAttribute("asset")]
	public GltfAsset Asset
	{
		get
		{
			return this._asset;
		}
		set
		{
			this._asset = value;
		}
	}

	/// <summary>
	/// An array of buffers.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("buffers")]
	public GltfBuffer[] Buffers
	{
		get
		{
			return this._buffers;
		}
		set
		{
			if ((value == null))
			{
				this._buffers = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._buffers = value;
		}
	}

	/// <summary>
	/// An array of bufferViews.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("bufferViews")]
	public GltfBufferView[] BufferViews
	{
		get
		{
			return this._bufferViews;
		}
		set
		{
			if ((value == null))
			{
				this._bufferViews = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._bufferViews = value;
		}
	}

	/// <summary>
	/// An array of cameras.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("cameras")]
	public GltfCamera[] Cameras
	{
		get
		{
			return this._cameras;
		}
		set
		{
			if ((value == null))
			{
				this._cameras = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._cameras = value;
		}
	}

	/// <summary>
	/// An array of images.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("images")]
	public GltfImage[] Images
	{
		get
		{
			return this._images;
		}
		set
		{
			if ((value == null))
			{
				this._images = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._images = value;
		}
	}

	/// <summary>
	/// An array of materials.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("materials")]
	public GltfMaterial[] Materials
	{
		get
		{
			return this._materials;
		}
		set
		{
			if ((value == null))
			{
				this._materials = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._materials = value;
		}
	}

	/// <summary>
	/// An array of meshes.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("meshes")]
	public GltfMesh[] Meshes
	{
		get
		{
			return this._meshes;
		}
		set
		{
			if ((value == null))
			{
				this._meshes = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._meshes = value;
		}
	}

	/// <summary>
	/// An array of nodes.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("nodes")]
	public GltfNode[] Nodes
	{
		get
		{
			return this._nodes;
		}
		set
		{
			if ((value == null))
			{
				this._nodes = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._nodes = value;
		}
	}

	/// <summary>
	/// An array of samplers.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("samplers")]
	public GltfSampler[] Samplers
	{
		get
		{
			return this._samplers;
		}
		set
		{
			if ((value == null))
			{
				this._samplers = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._samplers = value;
		}
	}

	/// <summary>
	/// The index of the default scene.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("scene")]
	public System.Nullable<int> Scene
	{
		get
		{
			return this._scene;
		}
		set
		{
			if ((value < 0))
			{
				throw new System.ArgumentOutOfRangeException("Scene", value, "Expected value to be greater than or equal to 0");
			}
			this._scene = value;
		}
	}

	/// <summary>
	/// An array of scenes.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("scenes")]
	public GltfScene[] Scenes
	{
		get
		{
			return this._scenes;
		}
		set
		{
			if ((value == null))
			{
				this._scenes = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._scenes = value;
		}
	}

	/// <summary>
	/// An array of skins.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("skins")]
	public GltfSkin[] Skins
	{
		get
		{
			return this._skins;
		}
		set
		{
			if ((value == null))
			{
				this._skins = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._skins = value;
		}
	}

	/// <summary>
	/// An array of textures.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("textures")]
	public GltfTexture[] Textures
	{
		get
		{
			return this._textures;
		}
		set
		{
			if ((value == null))
			{
				this._textures = value;
				return;
			}
			if ((value.Length < 1u))
			{
				throw new System.ArgumentException("Array not long enough");
			}
			this._textures = value;
		}
	}

	/// <summary>
	/// Dictionary object with extension-specific objects.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("extensions")]
	public System.Collections.Generic.Dictionary<string, object> Extensions
	{
		get
		{
			return this._extensions;
		}
		set
		{
			this._extensions = value;
		}
	}

	/// <summary>
	/// Application-specific data.
	/// </summary>
	[Newtonsoft.Json.JsonPropertyAttribute("extras")]
	public GltfExtras Extras
	{
		get
		{
			return this._extras;
		}
		set
		{
			this._extras = value;
		}
	}

	public GltfRoot() { }

	public GltfRoot(Dictionary<string, object> map)
	{
		var local = new Dictionary<string, object>(map, StringComparer.InvariantCultureIgnoreCase);
		foreach (var item in local)
		{
			var name = item.Key.ToLower();
			switch (name)
			{
				case "accessors":
					setMap(item.Value, ref this._accessors);
					break;
				case "animations":
					//setMap(item.Value, ref this._animations);
					break;
				case "asset":
					Asset = Newtonsoft.Json.JsonConvert.DeserializeObject<GltfAsset>(item.Value.ToString());
					break;
				case "buffers":
					setMap(item.Value, ref this._buffers);
					break;
				case "bufferviews":
					setMap(item.Value, ref this._bufferViews);
					break;
				case "cameras":
					setMap(item.Value, ref this._cameras);
					break;
				case "textures":
					setMap(item.Value, ref this._textures);
					break;
				case "extensionsused":
					ExtensionsUsed = Newtonsoft.Json.JsonConvert.DeserializeObject<string[]>(item.Value.ToString());
					break;
				case "images":
					setMap(item.Value, ref this._images);
					break;
				case "materials":
					setMap(item.Value, ref this._materials);
					break;
				case "meshes":
					setMap(item.Value, ref this._meshes);
					break;
				case "nodes":
					setMap(item.Value, ref this._nodes);
					break;
				case "programs":
					//setMap(item.Value, this.Programs);
					break;
				case "samplers":
					setMap(item.Value, ref this._samplers);
					break;
				case "scene":
					SceneName = item.Value.ToString();
					break;
				case "scenes":
					setMap(item.Value, ref this._scenes);
					break;
				case "shaders":
					setMap(item.Value, this.Shaders);
					break;
				case "skins":
					setMap(item.Value, ref this._skins);
					break;
				case "techniques":
					setMap(item.Value, this.Techniques);
					break;
				default:
					throw new NotImplementedException(name);
			}
		}
	}
	public string SceneName { get; set; }
	public Dictionary<string, object> Shaders { get; } = new();
	public Dictionary<string, object> Techniques { get; } = new();
	private Dictionary<string, object> getMap(string json)
	{
		return Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, object>>(json);
	}

	private void setMap<T>(object obj, Dictionary<string, T> arr)
	{
		var map = this.getMap(obj.ToString());
		foreach (var item in map)
		{
			var name = item.Key.ToLower();
			var json = item.Value.ToString();
			T t = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(item.Value.ToString());
			arr.Add(name, t);
		}
	}

	private void setMap<T>(object obj, ref T[] arr)
		where T : IGltfNamedObject
	{
		var map = this.getMap(obj.ToString());
		arr = new T[map.Count];
		for (int i = 0; i < map.Count; i++)
		{
			var item = map.ElementAt(i);
			var json = item.Value.ToString();
			T entry = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(json);
			entry.Name = item.Key;
			arr[i] = entry;
		}
	}

	public bool ShouldSerializeExtensionsUsed()
	{
		return ((_extensionsUsed == null)
					== false);
	}

	public bool ShouldSerializeExtensionsRequired()
	{
		return ((_extensionsRequired == null)
					== false);
	}

	public bool ShouldSerializeAccessors()
	{
		return ((_accessors == null)
					== false);
	}

	public bool ShouldSerializeAnimations()
	{
		return ((_animations == null)
					== false);
	}

	public bool ShouldSerializeAsset()
	{
		return ((_asset == null)
					== false);
	}

	public bool ShouldSerializeBuffers()
	{
		return ((_buffers == null)
					== false);
	}

	public bool ShouldSerializeBufferViews()
	{
		return ((_bufferViews == null)
					== false);
	}

	public bool ShouldSerializeCameras()
	{
		return ((_cameras == null)
					== false);
	}

	public bool ShouldSerializeImages()
	{
		return ((_images == null)
					== false);
	}

	public bool ShouldSerializeMaterials()
	{
		return ((_materials == null)
					== false);
	}

	public bool ShouldSerializeMeshes()
	{
		return ((_meshes == null)
					== false);
	}

	public bool ShouldSerializeNodes()
	{
		return ((_nodes == null)
					== false);
	}

	public bool ShouldSerializeSamplers()
	{
		return ((_samplers == null)
					== false);
	}

	public bool ShouldSerializeScene()
	{
		return ((_scene == null)
					== false);
	}

	public bool ShouldSerializeScenes()
	{
		return ((_scenes == null)
					== false);
	}

	public bool ShouldSerializeSkins()
	{
		return ((_skins == null)
					== false);
	}

	public bool ShouldSerializeTextures()
	{
		return ((_textures == null)
					== false);
	}

	public bool ShouldSerializeExtensions()
	{
		return ((_extensions == null)
					== false);
	}

	public bool ShouldSerializeExtras()
	{
		return ((_extras == null)
					== false);
	}
}
